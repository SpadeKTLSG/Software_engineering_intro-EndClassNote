‍

## 0 面向对象设计概念

设计是把分析阶段得到的**需求**转变成符合成本和质量要求的、抽象的系统实现方案的过程。从面向对象分析到面向对象设计是一个**逐渐扩充模型**的过程，即面向对象设计就是**用面向对象观点建立求解域模型的过程**

‍

### 设计与分析的关系

* 分析结果可以直接映射成**设计结果**，而在设计过程中又会加深和补充对系统需求的理解，进一步完善分析结果
* 分析和设计活动是一个**多次反复迭代**的过程
* 分析是**提取和整理用户需求，并建立问题域精确模型**的过程。设计则是把分析阶段得到的需求转变成符合成本和质量要求的、抽象的系统实现方案的过程

‍

### 分类

* **系统设计**:确定实现系统的策略和目标系统的高层结构
* **对象设计**:确定解空间中的类、关联、接口形式及实现服务的算法

‍

‍

## 1 面向对象设计的准则

‍

### 模块化

* 对象就是模块
* 把数据结构和操作这些数据的方法紧密地结合在一起

‍

### 抽象

* 过程抽象
* 数据抽象：类
* 参数化抽象：C++的“模板”

‍

‍

### 信息隐藏

* 通过对象的封装性实现
* 类分离了接口与实现，支持信息隐藏

‍

‍

### 高内聚

* 内聚衡量一个模块内各个元素彼此结合的紧密程度
* 在设计时应该力求做到高内聚
* 面向对象设计的3种内聚：

  服务内聚^（一个服务应该完成一个且仅完成一个功能）^、类内聚^（一个类应该只有一个用途）^、一般\特殊内聚^（一般一特殊结构应该是对相应的领域知识的正确抽取）^

‍

‍

### 低耦合

* 耦合：一个软件结构内不同模块之间互连的紧密程度
* 弱耦合：系统中某一部分的变化对其他部分的影响降到最低程度
* 对象之间的耦合：交互耦合&继承耦合

‍

‍

### 可重用

* 尽量使用已有的类
* 如果确实需要创建新类，则在设计这些新类的协议时，应该考虑将来的可重复使用性

‍

## 2 启发规则

‍

‍

### 设计结果应该清晰易懂

提高软件可维护性和可重用性的重要措施

‍

保证设计结果清晰易懂的主要因素

* 用词一致
* 使用已有的协议
* 减少消息模式的数目
* 避免模糊的定义

‍

### 一般一特殊结构的深度适当

类等级中包含的层次数适当, 一个中等规模(大约包含100个类)的系统中，类等级层次数应保持为7±2

‍

### 设计简单的类

尽量设计小而简单的类

‍

* 避免包含过多的属性
* 有明确的定义
* 尽量简化对象之间的合作关系
* 不要提供太多服务

‍

### 使用简单的协议

消息中的参数不要超过3个

‍

### 使用简单的服务

类中的服务通常都很小

‍

### 把设计变动减至最小

设计的早期阶段,变动较大，随着时间推移，设计方案日趋成熟改动也越来越小了

‍

‍

## 3 软件重用

‍

### 概述

**重用也叫再用或复用，是指同一事物不作修改或稍加改动就多次重复使用**

‍

软件重用可分为以下3个层次:

* 知识重用
* 方法和标准的重用
* 软件成分的重用

‍

#### 软件成分重用的级别

‍

##### 代码重用

* 源代码剪贴
* 源代码包含
* 继承

‍

##### 设计结果重用

* 重用某个软件系统的设计模型(即求解域模型)

‍

##### 分析结果重用

* 更高级别的重用，即重用某个系统的分析模型

‍

#### 典型的可重用软件成分

‍

* 项目计划
* 成本估计
* 体系结构
* 需求模型和规格说明
* 设计
* 源代码
* 用户文档和技术文档
* 用户界面
* 数据
* 测试用例

‍

‍

### 类构件

‍

#### 可重用软件构件特点

‍

* 模块独立性强
* 具有高度可塑性
* 接口清晰、简明、可靠

‍

#### 类构件的重用方式

**类构件**：面向对象技术中的“类”，是比较理想的可重用软构件

‍

‍

##### 实例重用

* 使用适当的构造函数，按照需要创建类的实例
* 用几个简单的对象作为类的成员创建出一个更复杂的类

‍

##### 继承重用

继承性提供了一种对已有的类构件进行裁剪的机制

‍

##### 多态重用

* 使对象的对外接口更加一般化，降低了消息连接的复杂程度
* 提供一种简便可靠的软构件组合机制

‍

在设计类构件时应把注意力集中在下列这些可能妨碍重用的操作上

* 与**表示方法有关**的操作
* 与**数据结构、数据大小**等因素有关的操作
* 与**外部设备**有关的操作
* 实现算法在将来可能会改变的**核心操作**

‍

### 软件重用的效益

‍

#### 质量

随着每一次重用， 都会有一些错误被发现并被清除，构件的质量也会随之改善。随着时间的推移，构件将变成实质上无错误的。重用给软件产品的质量和可靠性带来实质性的提高

‍

#### 生产率

把可重用的软件成分应用于软件开发的全过程时，创建计划、模型、文档、代码和数据所花费的时间将减少，从而用较少的投入给客户提供相同级别的产品，故生产率得到了提高

‍

#### 成本

软件重用带来的净成本节省可以用下式估算：

C=Cs-Cr-Cd

‍

* Cr是与重用相关联的成本
* Cd是交付给客户的软件的实际成本
* Cs使用第13章讲述的技术^（这这这）^来估算

‍

‍

## 4 系统分解

‍

### 分解思想

在设计比较复杂的应用系统时，先把系统分解成**若干个较小部分**，然后分别设计每个部分。这样做有利于降低设计的难度，有利于分工协作，也有利于维护人员对系统理解和维护

‍

### 子系统

**系统的主要组成部分**称为子系统，通常根据所提供的功能来划分子系统

‍

#### 划分原则

* 根据所提供的**功能**来划分子系统，子系统数目应该与系统规模基本匹配
* 各个子系统之间应该具有尽可能简单、明确的接口
* 应该尽量减少子系统彼此间的**依赖性**

‍

#### 面向对象设计模型

​![](https://img-blog.csdnimg.cn/df3104072247403c982d2ef2ba82ad56.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16)​

* 面向对象设计模型由**主题、类与对象、结构、属性、服务**5个层次组成。这5个层次一层比一层表示的细节更多，可以把这5个层次想象为整个模型的水平切片
* 面向对象设计模型在逻辑上都由4大部分组成，分别对应于组成目标系统的4个子系统,即**问题域子系统**、**人机交互子系统**、**任务管理子系统**和**数据管理子系统**

‍

### 子系统间交互方式

‍

#### 客户-供应商关系

作为“客户”的子系统调用作为“供应商”的子系统，后者完成某些服务工作并返回结果。作为客户的子系统必须了解作为供应商的子系统的接口，后者却无须了解前者的接口

‍

#### 平等伙伴关系

每个子系统都可能调用其他子系统，每个子系统都必须了解其他子系统的接口。由于各个子系统需要相互了解对方的接口，子系统之间的交互复杂，且还可能存在通信环路

> 总地说来，单向交互比双向交互更容易理解，也更容易设计和修改，因此应该尽量使用客户-供应商关系

‍

### 组织系统的方案

‍

#### 层次组织

软件系统组织成一个**层次系统**，每层是一个**子系统**。上层在下层的基础上建立，下层为实现上层功能而提供必要的**服务**。每一层内所包含的对象，彼此间**相互独立**，而处于不同层次上的对象，彼此间有关联。在上、下层之间存在**客户-供应商**关系。低层子系统提供服务，上层子系统使用下层提供的服务

‍

* **封闭式**：每层子系统仅仅使用其**直接**下层提供的服务。降低了各层次之间的相互依赖性，更容易理解和修改
* **开放式**：子系统可以使用处于其下面的任何一层子系统所提供的服务。优点是减少了需要在每层重新定义的服务数目，使系统更高效更紧凑。但其不符合**信息隐藏**原则

‍

#### 块状组织

把软件系统**垂直**地分解成若千个**相对独立的、弱耦合**的子系统，一个子系统相当于一块,每块提供**一种类型的服务**

‍

#### 层次和块状的结合

当混合使用层次结构和块状结构时，**同一层次可以由若干块组成，而同一块也可以分为若干层**

‍

##### 设计系统的拓扑结构

典型的拓扑结构有**管道形、树形、星形**等。应采用与问题结构相适应的、尽可能简单的拓扑结构，以减少子系统之间的交互数量

‍

‍

## 5 设计问题域子系统

‍

### 概念

* 面向对象分析所得出的问题域精确模型，为设计问题域子系统建立了**完整的框架**
* 保持面向对象分析所建立的**问题域结构**
* 面向对象设计仅需从**实现角度**对问题域模型做一-些补充或修改
* 问题域子系统过分复杂庞大时，应该把它进一步分解成若干个更小的子系统

‍

### 调整需求

‍

#### 需要进行调整的情况

* **用户需求**或**外部环境**发生了变化
* **分析员对问题域理解不透彻**或**不能完整、准确地反映用户的真实需求**

‍

#### 方法

简单地修改面向对象分析结果，然后再把这些修改反映到问题域子系统中

‍

### 重用已有的类

‍

重用已有类的典型过程为：

1. 在已有类中找出与问题域内某个最相似的类作为**被重用**的类
2. 从被重用的类派生出**问题域类 (添加泛化关系)**
3. 简化**对问题域类的定义**(从被重用的类继承的属性和服务无须再定义)
4. 修改**与问题域类相关**的关联，必要时改为与被重用的类相关的关联

‍

‍

### 把问题域类组合在一起

在面向对象设计过程中，设计者往往通过引入一个根类而把问题域类组合在一起

‍

### 添加一般化类以建立协议

设计过程中常常发现，一些具体类需要有一个公共的协议，可以引入**附加类**以便建立这个协议

‍

### 调整继承类层次

如果面向对象分析模型中包含了多重继承关系，然而所使用的程序设计语言却并不提供多重继承机制，则必须修改面向对象分析的结果

‍

‍

‍

## 6 设计人机交互子系统

‍

### 分类用户

应该把将来可能与系统交互的用户按技能水平，或按职务，或按所属集团进行分类

‍

### 描述用户

了解将来使用系统的每类用户的情况，把**用户类型**、使用目的、**特征**、关键的成功因素、**技能水平**、完成本职工作的脚本的信息记录下来

‍

### 设计命令层次

‍

#### 研究现有的人机交互含义和准则

设计图形用户界面时，应该遵守广大用户习惯的约定，这样才会被用户接受和喜爱

‍

#### 确定初始的命令层次

命令层次实质上是用**抽象**机制组织起来的、可供选用的服务的表示形式，设计命令层次时，通常先从对**服务的过程**抽象着手，然后进一步修改它们，以适合具体应用环境的需要

‍

#### 精化命令层次

为进一步修改完善初始的命令层次，应该考虑次序、整体部分关系、宽度和深度等因素

‍

### 设计人机交互类

人机交互类与所使用的操作系统及编程语言密切相关

‍

‍

## 7 设计任务管理子系统

‍

**必要性**

* 许多对象之间往往存在**相互依赖关系**
* 在实际使用的硬件中，可能仅由一个**处理器**支持多个对象

‍

### 分析并发性

‍

**并发性**

如果两个对象彼此间不存在交互，或它们同时接受事件，则它们在本质，上是并发的

‍

**方法**

通过检查各个对象的**状态图**及它们之间交换的事件，能够把若干个非并发的对象归并到一条控制线中

‍

**控制线**

控制线是一条**遍及状态图集合的路径**，在这条路径上**每次只有一个对象是活动的**。在计算机系统中用**进程**实现控制线。把多个任务的并发执行称为**多任务**

‍

### 设计任务管理子系统

‍

##### ①确定事件驱动型任务

某些任务是由事件驱动的，这类任务可能主要完成通信工作,优先任务可以满足高优先级或低优先级的处理需求具体任务有

* 任务处于睡眠状态，等待**来自数据线或其他数据源的中断**
* 一旦接收到中断就**唤醒该任务**，接收数据并把数据放入内存缓冲区或其他目的地，通知需要知道这件事的对象，然后该任务又回到睡眠状态

‍

‍

##### ②确定时钟驱动型任务

某些任务每隔一定时间间隔就被触发以执行某些处理，具体任务有

* 任务设置了**唤醒时间**后进入睡眠状态，等待来自系统的中断
* 接收到这种中断，任务就被唤醒并做它的工作，通知有关的对象，然后该任务又回到睡眠状态

‍

##### ③确定优先任务

优先任务可以满足高优先级或低优先级的处理需求

* **高优先级**：有些服务是优先级的，为了在严格限定的时间内完成，把这类服务分离成独立的任务
* **低优先级**：与高优先级相反，有些服务是低优先级的，属于低优先级处理。设计时用额外的任务把其分离出来

‍

##### ④确定关键任务

关键任务是有关系统成功或失败的关键处理，这类处理通常都有严格的**可靠性**要求。处理方法为：在设计过程中用**额外的任务把这样的关键处理分离出来**，以满足高可靠性处理的要求

‍

##### ⑤确定协调任务

当系统中存在**三个**以上任务时，就应该增加一个任务，用它作为协调任务。

使用**状态转换矩阵**可以比较方便地描述该任务的行为。这类任务仅做协调工作,不要让它再承担其他服务工作

‍

##### ⑥尽量减少任务数

‍

##### ⑦确定系统资源需求

综合考虑各种因素，以决定哪些子系统用硬件实现，哪些子系统用软件实现

* 通过计算**系统载荷**，来估算所需要的固件的处理能力
* 综合权衡一致性、成本、性能以及未来的可扩充性和可修改性，决定资源需求

‍

‍

## 8 设计数据管理子系统

系统存储或检索对象的基本设施，它建立在某种数据存储管理系统之上，并且隔离了数据存储管理模式的影响

‍

### 选择数据存储管理模式

‍

#### 文件管理系统

‍

* **优点**：文件管理系统是操作系统的一个组成部分，使用它长期保存数据具有**成本低**和**简单**的优点
* **缺点**：文件操作的**级别低**，为提供适当的抽象级别还必须编写**额外的代码**，不同操作系统的文件管理系统往往有明显差异

‍

#### 关系数据库管理系统

‍

**优点**：

* 理论基础**坚实**
* 提供了各种最基本的数据管理功能
* 为多种应用提供了**一致的接口**
* **标准化**的语言

‍

**缺点**：

* **运行开销大**：即使完成简单的事务，也需要较长的时间
* **不能满足高级应用的需求**：关系数据库管理系统是为商务应用服务的，商务应用中数据量虽大但数据结构却比较简单
* **与程序设计语言的连接不自然**: SQL语言支持面向集合的操作，是一种非过程化的语言; 然而大多数程序设计语言本质上却是过程性的，每次只能处理一个记录

‍

#### 面向对象数据库管理系统

两种设计途径

* **扩展的关系数据库管理系统**：在关系数据库的基础上，增加了抽象数据类型和继承机制，此外还增加了创建及管理类和对象的通用服务
* **扩展的面向对象程序设计语言**：扩充了面向对象程序设计语言的语法和功能，增加了在数据库中存储和管理对象的机制。可以使用统一的面向对象观点进行设计，不需要区分存储数据结构和程序数据结构

‍

(下略)

‍

‍

## 9 设计类中的服务

‍

‍

### 确定类中应有的服务

(简单)

‍

* 一张状态图描绘了一类对象的生命周期，图中的状态转换是执行对象服务的结果。
* 功能模型指明了系统必须提供的服务。
* 状态图中状态转换所触发的动作，在功能模型中有时可能扩展成一张数据流图。
* 数据流图中的某些处理可能与对象提供的服务相对应，有一些规则有助于确定操作的目标对象(即应该在该对象所属的类中定义这个服务)。
* 当一个处理涉及多个对象时，通常在起主要作用的对象类中定义这个服务。

‍

‍

### 设计实现服务的方法    

‍

#### 设计实现服务的算法

虑下列几个因素

* **算法复杂度**：选用复杂度较低(效率较高)的算法，但不能过分追求高效率，应以能满足用户需求为准
* **容易理解与容易实现**：容易理解与容易实现的要求往往与高效率有矛盾，设计者应该对这两个因素适当折衷
* **易修改**：预测将来可能做的修改，并在设计时预先做些准备

‍

#### 选择数据结构

分析阶段，仅需考虑系统中需要的信息的逻辑结构，在面向对象设计过程中，则需要选择能够方便、有效地实现算法的物理数据结构

‍

#### 算法与数据结构的关系

考虑下列因素

* 分析问题寻找数据特点，提炼出所有可行有效的算法
* 定义与所提炼算法相关联的数据结构
* 依据此数据结构进行算法的详细设计
* 进行一定规模的实验与评测
* 确定最佳设计

‍

#### 定义内部类和内部操作

增添一些用来存放在执行算法过程中所得出的中间结果的类，其需求陈述中没有提到。复杂操作往往可以用简单对象上的更低层操作来定义，因此，在分解高层操作时常常引入新的低层操作

‍

‍

## 10 设计关联

> 1:1, 1:n, n:n的设计理念

‍

### 关联的遍历

在应用系统中，使用关联有两种可能的方式：单向遍历和双向遍历。  
在使用原型法开发软件的时候，原型中所有关联都应该是双向的，以便于增加新的行为，快速地扩充和修改原型

‍

### 实现单向关联

用指针可以方便地实现单向关联。

如果关联的重数是一元的，则实现关联的指针是一个简单指针

如果重数是多元的，则需要用一个指针集合实现关联

‍

### 实现双向关联

3种方法

* 只用属性实现一个方向的关联
* 两个方向的关联都用属性实现
* 用独立的关联对象实现双向关联

‍

### 关联对象的实现

可以引入一个关联类来保存描述关联性质的信息，关联中的每个连接对应着关联类的一个对象

* 对于一对一关联来说，关联对象可以与参与关联的任一个对象合并。
* 对于一对多关联来说，关联对象可以与“多”端对象合并
* 如果是多对多关联，则关联链的性质不可能只与一个参与关联的对象有关，通常用一个独立的关联类来保存描述关联性质的信息，这个类的每个实例表示一条具体的关联链及该链的属性

‍

‍

## 11 设计优化

‍

### 确定优先级

各项质量指标并不是同等重要的，设计人员必须确定各项质量指标的相对重要性

‍

### 提高效率的几项技术

> 参考MySQL提升查询效率思想

‍

#### 增加冗余关联以提高访问效率

‍

#### 调整查询次序

‍

#### 保留派生属性

‍

### 调整继承关系

‍

#### 抽象(到)具体

‍

#### 为提高继承程度而修改类定义

(抽取)

‍

#### 利用委托实现行为共享

(持有其他对象实例)

‍
