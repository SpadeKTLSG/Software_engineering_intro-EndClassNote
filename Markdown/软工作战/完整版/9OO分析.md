‍

* 面向对象分析中，主要由对象模型、动态模型和功能模型组成
* 面向对象分析的关键工作，是分析、确定问题域中的对象及对象间的关系，并建立起问题域的对象模型

‍

‍

## 1 面向对象分析的基本过程

抽取和整理用户需求并建立问题域精确模型的过程

‍

### 概念

‍

#### **主题**

指导读者理解大型、复杂模型的一种机制。即通过划分主题把一个大型、复杂的对象模型分解成几个不同的概念范畴

‍

#### 7 +- 2 原则

短期记忆能力一般限于**一次记忆5~9个对象**

面向对象从两个方面体现这条原则

* 控制可见性：控制读者能见到的层次数目来控制可见性
* 指导读者注意力：增加了主题层，可从高层次描述总体模型，并指导读者的注意力

‍

#### 面向对象分析顺序

1. 寻找类与对象
2. 识别结构
3. 识别主题
4. 定义属性
5. 建立动态模型
6. 建立功能模型
7. 定义服务

‍

#### 建模要点

* 面向对象分析**不可能严格按照顺序线性进行**
* 必须在反复分析中**对初始模型中不准确、不完整和错误**的内容加以扩充和更正
* 仔细研究**类似问题的分析结果**，尽可能**重用**这些结果

‍

### 3个子模型

面向对象建模得到的模型包含系统的三个要素

‍

#### **静态结构（对象模型）**

解决任一问题，都需要从客观世界实体及实体间相互关系抽象出极有价值的对象模型

‍

#### **交互次序（动态模型）**

当问题涉及交互作用和时序时，动态模型是重要的

‍

#### **数据变换（功能模型）**

解决运算量很大的问题，则涉及重要的功能模型

‍

‍

### 5个层次

复杂问题的对象模型由5个层次组成:**主题层、类与对象层、结构层、属性层和服务层**。这5个层次一层比一层显现出对象模型的更多细节

‍

‍

## 2 需求陈述

> 请同学你讲下你项目中对象的操作场景

‍

### 内容

* 阐明“**做什么**”而不是“怎样做”
* 描述**用户的需求**而不是提出解决问题的方法
* 指出哪些是**系统必要的性质**，哪些是任选的性质
* 避免对**设计策略施加过多的约束**，不描述系统的**内部结构**
* 描**述系统性能**及**系统与外界环境交互协议**
* 描述采用的**软件工程标准、模块构造准则、将来的扩充以及可维护性要求**等方面

‍

‍

### 书写规范

* 做到**语法正确**，而且应该**慎重选用名词、动词、形容词和同义词**
* 必须把**需求与实现策略区分开**，后者不是问题域的本质性质
* 需求陈述**可简可繁**
* 避免出现具有**二义性的、不完整的、不一致**的内容

‍

‍

## 3 建立对象模型

‍

### (1) 基本概念

‍

#### 对象模型

面向对象分析的首要工作就是建立问题域的**对象模型**。

对象模型表示**静态的、结构化的系统的**数据性质。它是对模拟客观世界实体的对象以及对象彼此间的关系的映射，描述了系统的**静态结构**。对象模型为建立动态模型和功能模型，提供了实质性的框架

‍

**原因**

* 静态数据结构对**应用细节**依赖较少，比较容易确定
* 当用户的需求变化时，静态数据结构相对来说**比较稳定**

‍

**信息来源**

需求陈述、应用领域的专业知识、客观世界的常识，是建立对象模型时的主要信息来源

‍

‍

#### 典型的建模步骤

‍

* 确定对象**类和关联**(对于大型复杂问题还要进一步划分出若干个主题)
* 给类和关联增添**属性**，以进一步描述它们
* 使用适当的**继承**关系进一步合并和组织类
* 对类中操作的最后确定，则需等到建立了动态模型和功能模型之后，因为这两个子模型更准确地描述了对类中提供的服务的需求。

‍

‍

### (2) 确定类与对象

‍

#### 找出候选的类与对象

‍

##### 客观事物分类法

‍

**对象是对问题域中有意义的事物的抽象，它们既可能是物理实体，也可能是抽象概念**。

客观事物可分为下述5类:

* 可感知的物理实体
* 人或组织的角色
* 应该记忆的事件
* 两个或多个对象的相互作用
* 需要说明的概念

‍

‍

##### 非正式分析法

‍

以用自然语言书写的需求陈述为依据，把陈述中的**名词作为类与对象的候选者**, 用**形容词作为确定属性的线索**，把**动词作为服务的候选者**

这种方法确定的候选者是非常不准确的，其中往往包含大量不正确或不必要的事物，需要经过**更进一步的严格筛选**

‍

‍

#### 筛选出正确的类与对象

‍

##### 冗余

如果两个类表达了同样的信息，则应该保留在此问题域中**最富于描述力**的名称

‍

##### 无关

需要把**与本问题密切相关的类与对象**放进目标系统中

‍

##### 笼统

系统无须记忆**笼统的、泛指的名词信息**，把这些笼统的或模糊的类去掉

‍

##### 属性

把描述的是**其他对象属性的词**从候选类与对象中去掉

‍

##### 操作

慎重考虑**既可作为名词，又可作为动词的词**，以便正确地决定把它们作为类还是作为类中定义的操作。本身具有属性，需独立存在的操作，应该作为类与对象

‍

##### 实现

应该去掉**仅和实现**有关的候选的类与对象

‍

‍

### (3) 确定关联

‍

**关联**

两个或多个对象之间的**相互依赖、相互作用**的关系就是关联。在需求陈述中使用的**描述性动词或动词词组**,通常表示关联关系

‍

**确定关联的重要性**

分析确定关联，能促使分析员考**虑问题域的边缘情况**，有助于发现**尚未被发现的类与对象**

‍

#### 初步确定关联

* 直接提取**动词短语**得出的关联
* **需求陈述**中隐含的关联
* 根据**问题域知识**得出的关联

‍

#### 筛选

根据下述标准**删除**候选的关联

‍

* **已删去的类之间的关联**：如果在分析确定类与对象的过程中已经删掉了某个候选类，则与这个类有关的关联也应该删去，或用其他类重新表达这个关联
* **与问题无关的或应在实现阶段考虑的关联**：应该把处在本问题域之外的关联与实现密切相关的关联删去
* **瞬时事件**：关联应该描述问题域的静态结构，而不应该是一个瞬时事件
* **三元关联**：三个或三个以上对象间的关联，可分解为二元关联或用词组描述成限定的关联
* **派生关联**：去掉那些可以用其他关联定义的冗余关联

‍

‍

#### 完善

‍

* **正名**：仔细选择含义更明确的名字作为关联名
* **分解**：为了能够适用于不同的关联，必要时应该分解以前确定的类与对象
* **补充**：发现了遗漏的关联就应该及时补上
* **标明重数**：应该初步判定各个关联的类型，并粗略地确定关联的重数

‍

如此即可获得原始的类图

‍

‍

### (4) 划分主题

在开发大型、复杂系统的过程中，为了降低复杂程度,把系统再进一步划分成几个不同的主题，即在概念上把系统包含的内容分解成若干个范畴

‍

#### 针对不同类型的方法

* **规模小的系统**：可能无须引入主题层
* **含有较多对象的系统**：首先识别出类与对象和关联，然后划分主题，并用它作为指导开发者和用户观察整个模型的一种机制
* **规模大的系统**：首先由高级分析员粗略地识别对象和关联，然后初步划分主题，经进一步分析，对系统结构有更深入的了解之后，再进一步修改和精炼主题

‍

#### 原则

* 按**问题领域**而不是用功能分解方法来确定主题
* 按照**使不同主题内的对象相互间依赖和交互最少**的原则来确定主题

‍

### (5) 确定属性

属性是对象的性质，借助于属性人们能对类与对象和结构有更深入更具体的认识

* 注意:在分析阶段不要用属性来表示对象间的关系，使用关联能够表示两个对象间的任何关系，而且把关系表示得更清晰、更醒目

‍

#### 分析

* 在需求陈述中用**名词词组**表示属性，用**形容词**表示可枚举的具体属性
* 借助于**领域知识**和**常识**分析需要的属性
* 仅考虑与**具体应用**直接相关的属性，不要考虑那些超出所要解决的问题范围的属性
* 首先找出**最重要**的属性，以后再逐渐把其余属性增添进去
* 不要考虑那些**纯粹用于实现**的属性

‍

#### 选择

从初步分析确定下来的属性中删掉不正确的或不必要的属性

* **误把对象当作属性**：如果某个实体的独立存在比它的值更重要，则应把它作为一个对象而不是对象的属性
* **误把关联类的属性当作一般对象的属性**：如果某个性质依赖于某个关联链的存在，则该性质是关联类的属性，在分析阶段不应把它作为一般对象的属性
* **把限定误当成属性**：如果把某个属性值固定下来以后能减少关联的重数，则应该考虑把这个属性重新表达成一个限定词。
* **误把内部状态当成了属性**：如果某个性质是对象的非公开的内部状态，则应该从对象模型中删除这个属性。
* **过于细化**：在分析阶段应该忽略那些对大多数操作都没有影响的属性
* **存在不一致的属性**：类应该是简单而且一致的。如果得出一些看起来与其他属性毫不相关的属性，则应该考虑把类分解成两个不同的类

‍

‍

### (6) 识别继承关系

‍

#### 建立继承关系的方式

确定了类中应该定义的属性之后，就可以利用继承机制共享公共性质，并对系统中众多的类加以组织。可以使用以下两种方式建立继承关系

‍

* **自底向上**：抽象出现有类的共同性质泛化出父类，这个过程实质上模拟了人类**归纳**思维的过程
* **自顶向下**：把现有类细化成更具体的子类,这模拟了人类的**演绎**思维过程。从应用域中常常能明显看出应该做的自顶向下的具体化工作

‍

#### 多重继承

利用多重继承可以**提高共享程度**，但增加了**概念上以及实现时**的复杂程度

‍

要点

* 指定一个**主要父类**，从它继承大部分属性和行为;
* 次要父类只补充一些属性和行为

‍

‍

### (7) 反复修改

‍

#### 必要性

软件开发过程就是一个**多次反复修改、逐步完善**的过程。仅仅经过一次建模过程很难得到完全正确的对象模型

‍

#### 面向对象在修改时的优点

面向对象的概念和符号在整个开发过程中都是**一致的**，比使用结构分析、设计技术更容易实现反复修改、逐步完善的过程

‍

‍

## 4 建立动态模型

‍

### 概念

‍

#### 适用性

* 对于**仅存储静态数据的**系统来说，动态模型并没有什么意义
* 在开发**交互式系统**时，动态模型却起着很重要的作用
* **收集输入信息**是系统的主要工作时，则在开发时建立正确的动态模型是至关重要的

‍

#### 步骤

1. 编写典型**交互行为**的脚本
2. 从脚本中提取出事件，确定**触发每个事件的动作对象以及接受事件的目标对象**
3. 排列事件发生的**次序**，确定每个对象的**状态及状态间的转换关系**，用**状态图**描绘
4. 比较各个对象的状态图，确保事件之间的**匹配**

‍

‍

### (1) 编写脚本

脚本是指**系统在某一执行期间内出现的一系列事件**。脚本描述用户与目标系统之间的一个或多个典型的交互过程。编写脚本的过程，就是**分析用户对系统交互行为的要求的过程**

‍

#### 目的

保证**不遗漏重要的交互步骤**，有助于确保交互过程的**正确性、清晰性**

‍

#### 内容

脚本描写的范围主要由编写脚本的具体目的决定，既可以包括**系统中发生的全部事件**，也可以只包括由**某些特定对象触发的事件**

‍

#### 方法

* 编写正常情况的脚本
* 考虑特殊情况
* 考虑出错情况

‍

‍

### (2) 设想用户界面

用户界面的美观程度、方便程度、易学程度以及效率等，是用户使用系统时最先感受到的。用户界面的好坏往往对用户是否喜欢、是否接受一个系统起很重要的作用

‍

#### 目的

这个阶段用户界面的细节并不太重要，重要的是在这种界面下的**信息交换方式**。目的是确保能够完成**全部必要的信息交换**，而不会丢失重要的信息

‍

#### 方法

快速地建立起用户界面的原型，供用户试用与评价

‍

‍

### (3) 画事件跟踪图

用自然语言书写的脚本往往**不够简明**，而且有时在阅读时会有二义性。为了有助于建立动态模型，需要画出事件跟踪图

‍

#### 1.确定事件

提取出所有外部事件

* 找出**正常事件**、**异常事件**和**出错条件**(传递信息的对象的动作也是事件)
* 把**对控制流产生相同效果的事件**组合为一类事件，并取一个**唯一的名字**

‍

#### 2.画出事件跟踪图

‍

* 一条竖线代表一个**对象**
* 每个事件用一条**水平的箭头线**表示
* 箭头方向从事件的**发送对象指向接受对象**
* 时间从**上向下**递增
* 用箭头线在垂直方向上的相对位置表示**事件发生的先后**，不表示事件间的时间差

‍

‍

### (4) 画状态图

状态图描绘**事件与对象状态的关系**。当对象接受了一个事件以后，它的下个状态取决于**当前状态及所接受的事件**。由事件引起的改变称为“**转换**”。一张状态图描绘了**一类对象的行为**，它确定了**由事件序列引出的状态序列**

‍

#### 适用性

对于**仅响应与过去历史无关的那些输入事件**,或者**把历史作为不影响控制流的参数类**的对象，状态图是不必要的

‍

‍

#### 方法

* 仅考虑事件跟踪图中**指向某条竖线的那些箭头线**。把这些事件作为状态图中的**有向边**，边上标以**事件名**
* 两个事件之间的间隔就是一个**状态**，每个状态取个有意义的名字。从**事件跟踪图中当前考虑的竖线射出的箭头线**，是这条竖线代表的对象达到某个状态时所做的行为。
* 根据一张事件跟踪图画出状态图后，再把**其他脚本的事件跟踪图**合并到该图中
* 考虑完正常事件后再考虑**边界情况和特殊情况**，包括在不适当时候发生的事件

‍

‍

### (5) 审查动态模型

* 检查系统级的**完整性**和**一致性**
* 审查每个事件，跟踪**它对系统中各对象所产生的效果**，保证与每个脚本都匹配

‍

‍

## 5 建立功能模型

功能模型表明了**系统中数据之间的依赖关系**，以及有关的数据处理功能，它由一组**数据流图**组成。在建立了对象模型和动态模型之后再建立功能模型

‍

### (1) 画出基本系统模型图

基本的系统模型有下述两部分组成:

* **数据源点/终点**：数据源点输入的数据和输出到数据终点的数据，是**系统与外部世界**间交互事件的参数
* **处理框**：代表了**系统加工**、**变换数据**的整体功能

‍

### (2) 画出功能级数据流图

把基本系统模型中单一的处理框分解成**若干个处理框**，以描述系统加工、变换数据的**基本功能**，就得到功能级数据流图

‍

### (3) 描述处理框功能

‍

#### 要点

着重描述**每个处理框所代表的功能**，而不是实现功能的具体算法

‍

#### 分类

* **说明性描述（更为重要）** ：规定了**输入值和输出值**之间的关系，以及**输出值**应遵循的规律
* **过程性描述**：通过算法说明 做什么

‍

‍

## 6 定义服务

‍

“对象”是由描述其属性的数据，及可以对这些数据施加的操作(即服务)，封装在一起构成的独立单元。因此，为建立完整的对象模型，既要确定类中应该定义的属性，又要确定类中应该定义的服务

在确定类中应有的服务时，既要考虑该类实体的常规行为，又要考虑在本系统中特殊需要的服务。

‍

‍

### 常规行为

在分析阶段可以认为，类中定义的每个属性都是可以访问的，也就是说，假设在每个类中都定义了读、写该类每个属性的操作。但是，通常无须在类图中显式表示这些常规操作

‍

‍

### 从事件导出的操作

状态图中发往对象的事件也就是该对象接收到的消息，因此该对象必须有由消息选择符指定的操作，这个操作修改对象状态(即属性值)并启动相应的服务。

所启动的这些服务通常就是接受事件的对象在相应状态的行为

‍

‍

### 与数据流图中处理框对应的操作

数据流图中的每个处理框都与一个对象(也可能是若干个对象)上的操作相对应。应该仔细对照状态图和数据流图，以便更正确地确定对象应该提供的服务

‍

‍

### 利用继承减少冗余操作

应该尽量利用继承机制以减少所需定义的服务数目。只要不违背领域知识和常识，就尽量抽取出相似类的公共属性和操作，以建立这些类的新父类，并在类等级的不同层次中正确地定义各个服务

‍
