‍

* 面向对象实现主要包括两项工作

  * 把面向对象设计结果翻译成用某种程序语言书写的面向对象程序
  * 测试并调试面向对象的程序
* 目前，软件测试仍然是保证软件可靠性的主要措施

  * 面向对象测试的目标，也是用尽可能低的测试成本发现尽可能多的软件错误

‍

‍

## 1 程序设计语言

‍

### OO语言的优点

* **一致的表示方法**：面向对象开发基于不随时间变化的、一致的表示方法。既有利于在软件开发过程中始终使用统一的概念，也有利于维护人员理解软件的各种配置成分
* **可重用性**：既可重用面向对象分析结果，也可重用相应的面向对象设计和面向对象程序设计结果
* **可维护性**：程序显式地表达问题域语义，对维护人员理解待维护的软件有很大帮助。在选择编程语言时，应该考虑的首要因素是哪个语言能最恰当地表达问题域语义

‍

### OO语言的技术特点

‍

#### 支持类与对象概念的机制

面向对象语言允许用户动态创建对象，并且可以用指针引用动态创建的对象。需要及时释放不再需要的对象所占用的内存

‍

#### 实现聚集结构的机制

* 使用**指针**
* 使用独立的**关联对象**

‍

#### 实现一般-特殊（即泛化）结构的机制

* 实现**继承**的机制
* 解决**名字冲突**的机制，即处理在多个基类中可能出现的重名问题

‍

#### 实现属性和服务的机制

‍

**实现属性的机制**：

* 支持**实例连接**的机制
* 属性的**可见性**控制
* 对**属性值**的约束

‍

**实现服务的机制**：

* 支持**消息连接**(表达对象交互关系)的机制
* 控制**服务可见性**的机制
* **动态联编**(在发送消息前，无须知道接受消息的对象属于哪个类)

‍

#### 类型检查

‍

##### 分类

* **弱类型**：语言仅要求每个变量或属性隶属于一个对象
* **强类型**：语法规定每个变量或属性必须准确地属于某个特定的类

‍

##### 强类型语言的优点

* 有利于在编译时发现程序错误，提高软件的**可靠性**
* 增加了**优化**的可能性，提高软件的运行效率

‍

##### 适用性

使用强类型编译型语言开发**软件产品**，使用弱类型解释型语言快速开发**原型**

‍

#### 类库

存在类库，许多软构件就不必由程序员从头编写了，为实现软件重用带来很大方便。

‍

‍

#### 效率

‍

提高效率的方法有

* 使用拥有完整类库的面向对象语言
* 优化查找继承树查找过程，从而实现高效率查找

‍

#### 持久保存对象

‍

##### 原因

* 为实现**在不同程序之间传递数据**，需要保存数据
* 为恢复被**中断了的程序的运行**，首先需要保存数据

‍

##### 方法

* 在类库中增加**对象存储管理**功能
* 使程序设计语言语法与对象存储管理语法**无缝集成**

‍

‍

#### 参数化类

参数化类是使用一个或多个类型去参数化一个类的机制，如果程序语言提供一种能抽象出这类共性的机制，则对减少冗余和提高可重用性是大有好处的

‍

##### 方法

* 定义一个**参数化的类模板**
* 把**数据类型**作为参数传递进来

‍

#### 开发环境

* 编辑程序
* 编译程序或解释程序(最重要)
* 浏览工具
* 调试器

‍

‍

### 选择标准

* **将来能否占主导地位**
* **可重用性**
* **类库和开发环境**
* **其他因素**

‍

‍

‍

## 2 程序设计风格

‍

### 概念

‍

#### 良好的程序设计风格对保证程序质量的重要性

‍

良好的程序设计风格

* 能明显减少维护或扩充的开销
* 有助于在新项目中重用已有的程序代码

‍

良好的**面向对象程序设计风格**

* 不仅包含传统的程序设计风格准则
* 为适应面向对象方法所特有的概念而必须遵循的一些新准则

‍

### 提高可重用性

‍

代码重用

* **内部重用**：即本项目内的代码重用，主要是找出设计中相同或相似的部分，然后利用继承机制共享它们
* **外部重用**：即新项目重用旧项目的代码，需要有长远眼光，反复考虑，精心设计

‍

#### 提高方法的内聚

一个方法(即服务)应该只完成单个功能。如果某个方法涉及两个或多个不相关的功能，则应该把它分解成几个更小的方法

‍

#### 减小方法的规模

(可重用性)

如果某个方法规模过大, 则应该把它分解成几个更小的方法

‍

#### 保持方法的一致性

保持方法的一致性，有助于实现代码重用，功能相似的方法应该有一致的名字、参数特征、返回值类型、使用条件及出错条件等

‍

#### 把策略与实现分开

不要把策略和实现放在同一个方法中，应该把算法的核心部分放在一个单独的具体实现方法中。为此需要从策略方法中提取出具体参数，作为调用实现方法的变元

‍

从所完成的功能看，有两种不同类型的方法

* **策略方法**：负责做出决策，提供变元，并且管理全局资源
* **实现方法**：负责完成具体的操作，但却并不做出是否执行这个操作的决定，也不知道为什么执行这个操作

‍

‍

#### 全面覆盖

* 输入条件的各种组合都可能出现，应**针对所有组合写出方法**
* 一个方法对空值、极限值及界外值等异常情况也应能够做出有意义的响应

‍

‍

#### 尽量不使用全局信息

尽量降低方法与外界的耦合程度

‍

‍

#### 利用继承机制    

‍

* **调用子过程**：把公共的代码分离出来，构成一个被其他方法调用的公用方法
* **分解因子**：提高相似类代码可重用性的一个有效途径，是从不同类的相似方法中分解出不同的代码，把余下的代码作为公用方法中的公共代码，把分解出的因子作为名字相同算法不同的方法，放在不同类中定义，并被这个公用方法调用
* **使用委托**：当确实存在一般-特殊关系时，使用继承才是恰当的。继承机制使用不当将造成程序难于理解、修改和扩充。当逻辑上不存在一般-特殊关系时，为重用已有的代码，可以利用委托机制
* **把代码封装在类中**：重用通过其他方法编写的、解决同一类应用问题的程序代码的一个比较安全的途径是把被重用的代码封装在类中

‍

‍

### 提高可扩充性

‍

主要准则

* **封装实现策略**：应该把类的实现策略封装起来，对外只提供公有的接口，否则将降低今后修改数据结构或算法的自由度
* **不要用一个方法遍历多条关联链**：一个方法应该只包含对象模型中的有限内容。违反这条准则将导致方法过分复杂，既不易理解，也不易修改扩充
* **避免使用多分支语句**：可以利用DO_CASE语句测试对象的内部状态，而不要用来根据对象类型选择应有的行为，否则在增添新类时将不得不修改原有的代码
* **精心确定公有方法:**  公有方法是向公众公布的接口。对这类方法的修改往往会涉及许多其他类

‍

‍

### 提高健壮性

‍

主要准则

* **预防用户的错误操作**
* **检查参数的合法性**
* **不要预先确定限制条件**
* **先测试后优化**

‍

‍

## 3 测试策略

‍

### 经典的测试策略

测试软件的经典策略是，从“小型测试”开始，逐步过渡到“大型测试”

‍

* 单元测试
* 集成测试
* 确认测试、系统测试

‍

### 面向对象测试策略

‍

#### 面向对象的单元测试

最小的可测试单元是封装起来的**类和对象**。测试面向对象软件时，不能再孤立地测试单个操作，而应该**把操作作为类的一部分来测试**。在测试面向对象的软件时，传统的单元测试方法是**不适用的**，不能再在“真空”中(即孤立地)测试单个操作

‍

#### 面向对象的集成测试

‍

##### ①策略

* 基于线程的测试：把响应系统的一个输入或一个事件所需要的那些类集成起来。分别集成并测试每个线程，同时应用回归测试以保证没有产生副作用
* 基于使用的测试：不使用服务器类的独立类，把独立类都测试完之后，再测试使用独立类的下一个层次的类(称为依赖类)。对依赖类的测试一层一层次地测试，直至把整个软件系统构造完为止

‍

##### ②集群测试

集群测试是面向对象软件集成测试的一个步骤。在这个测试步骤中，用精心设计的测试用例检查一群相互协作的类，这些测试用例力图发现协作错误

‍

‍

#### 面向对象的确认测试

在确认测试或系统测试层次，不再考虑类之间相互连接的细节。面向对象软件的确认测试也集中检查用户可见的动作和用户可识别的输出。为了导出确认测试用例,测试人员应该认真研究动态模型和描述系统行为的脚本，以确定最可能发现用户交互需求错误的情景

‍

‍

## 4 设计测试用例

‍

### 测试类的方法

测试单个类的方法主要有随机测试、划分测试和基于故障的测试3种

‍

#### 随机测试

‍

#### 划分测试

减少测试类时所需要的测试用例的数量

‍

流程

* **把输入和输出分类**
* **设计测试用例以测试划分出的每个类别**

‍

方法

* **基于状态的划分**：根据类操作改变类状态的能力来划分类操作
* **基于属性的划分**：根据类操作使用的属性来划分类操作
* **基于功能的划分**：根据类操作所完成的功能来划分类操作

‍

#### 基于故障的测试

‍

‍

### 集成测试方法

‍

#### 多类测试

‍

##### 随机测试

* 对每个客户类，使用**类操作符列表**来生成一系列随机测试序列
* 对所生成的每个消息，确定**协作类**和在服务器对象中的对应操作符
* 对服务器对象中的每个操作符，确定**传递的消息**
* 对每个消息，确定**下一层被调用的操作符**，并把这些操作符结合进测试序列中

‍

##### 划分测试

* 应该扩充测试序列以包括那些通**过发送给协作类的消息**而被调用的操作
* 根据**与特定类的接口**来划分类操作

‍

‍

#### 从动态模型导出测试用例

状态图可以帮助人们导出测试该类的**动态行为的测试用例**

**通过导出大量的测试用例，保证该类的所有行为都被适当地测试了。在类的行为导致与一个或多个类协作的情况下，应该使用多个状态图去跟踪系统的行为**

‍
